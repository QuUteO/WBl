package main

import "fmt"

/*
	Применимость:
	- когда необходимо интегрировать какой-то стронней библиотеки без переписывания клиентской логики
	- когда есть клиент, ожидающий один интерфейс, а у нас есть несовместимый
	Пюсы:
	- Принцип открытости/закрытости (можно вводить новые адаптеры без изменения клиентской логики)
	- Упрощенная интеграция (можно без каких-либо проблем интегрировать другие библиотеки)
	Минусы:
	- Усложнение кодовой базы (увеличивает количество классов и общую сложность системы)
	- Маскировка несовместимости ( Может скрыть фундаментальную несовместимость компонентов, приводя к ошибкам во время выполнения вместо ошибок компиляции)
	Реальные примеры:
	- Интеграция платежных систем
	- Унификация логгеров
	- Работа с разными базами данных
*/

type Logger interface {
	Log(message string)
}

// старый код который нельзя менять
type OldLogger struct{}

func (l *OldLogger) WriteLog(message string) {
	fmt.Println(message)
}

// адаптер который мы будем оборачивать старый код
type LoggerAdapter struct {
	old *OldLogger
}

// метод который удовлетворяет нашему интерфейсу
func (l *LoggerAdapter) Log(message string) {
	l.old.WriteLog(message)
}

func main() {
	var logger Logger

	logger = &LoggerAdapter{old: &OldLogger{}}

	logger.Log("Лог адаптер")
}
